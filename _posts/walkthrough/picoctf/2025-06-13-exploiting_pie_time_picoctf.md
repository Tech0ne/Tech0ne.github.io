---
title: Exploiting "PIE TIME" on picoCTF
author: tech0ne
date: 2025-06-13 15:00:00 +0100
categories: [walkthrough, picoctf, binary-exploitation]
comments: true
toc: true
pin: false
tags: [walkthrough, picoctf, linux, programming, c, binary-exploitation, pwntools]
math: true
mermaid: true
---

# Introduction

Today, I played a CTF on picoCTF, and was like "Hey, that was fun, I should make a walkthrough / post about it !"

So here we are ;) !

Hope you'll enjoy this, and let's get this done !

# Disclamer

> This is a COMPLETE WALKTHROUGH giving a FULL AND WORKING solution. It's HIGHLY advised to do the CTF before looking at this !
{: .prompt-danger }

With that said, let's go over what we'll do in today's post.

# The CTF

First of all, let's talk about the CTF itself.

It's a binary exploitation challenge, hosted [here](https://play.picoctf.org/practice/challenge/490).

It's ranked `easy`, and was introduced on "picoCTF 2025".

For the files included, we have:

- The C source code (detailed later).
- The compiled binary (which I won't include here, for security reasons (never execute a binary given by a random stranger on the internet (; )).

# Initial lookup

Ok, what's the content of this C source code ?

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```
{: file="vuln.c" }

Hmmmm, intresting.

By the name of the challenge, we can see that the main focus will be PIE bypass.

Before diveing into what is PIE and how we can bypass it, let's take a look at the compiled executable.

We'll check it's security using `checksec`:

![checksec on vuln](/assets/img/posts/walkthrough/picoctf/pie_time/checksec.png "checksec on vuln")

We can confirm that PIE is enabled.

We can also run objdump to disassemble the executable (this is gonna come in handy after)

![objdump on vuln](/assets/img/posts/walkthrough/picoctf/pie_time/objdump.png "objdump on vuln")

We'll note the address of main, for later, as `000000000000133d` in hexadecimal (so `0x133d`, or `4925` in decimal)

# Source code auditing

This code let's you jump to whatever address you want, after giving you the address of main (that's a shellcode dream ;) ).

The line 48 is the moment the process jumps to the provided addres.

We also have a win function, giving us the flag.

Based on that, the flow is as follow:

Retreive the address of win, and give it to scanf to jump to it.

Let's try this out !

# First run

> So, the address of main being `0x133d`, it should print that when run, right ?
{: .prompt-info }

Well, let's try ;)

![first run. main is not 0x133d](/assets/img/posts/walkthrough/picoctf/pie_time/first_run.png "first run. main is not 0x133d")

> What ? Why isn't main at `0x133d`, as we saw on the objdump output ?
{: .prompt-info }

Well, this is because of _PIE_.

Before making the exploit work, let's naively put the address of `win`, as found on the objdump output. We'll see why it won't work after ;)

![objdump, retreiving the address of win as 0x12a7](/assets/img/posts/walkthrough/picoctf/pie_time/objdump_win.png "objdump, retreiving the address of win as 0x12a7")

Let's run it, and give it the address `0x12a7`

![it didn't work :(](/assets/img/posts/walkthrough/picoctf/pie_time/fail_with_win_offset.png "it didn't work :(")

> Ok, that's fun and all, but why tho ?
{: .prompt-info }

Well, this is because of **PIE** !

## What is PIE ?

PIE, for `Position Independent Executable`, is an option you can enable when you build you code.

This option will change how your code is compiled, by assigning functions _offsets_ instead of hardcoding their addresses.

The goal is, as we'll see, to prevent potential attackers from knowing the address of other functions.

This way, it's harder to successfully controle the execution flow: You don't know what is where.

![as we can see, re-running the executable gives us another address](/assets/img/posts/walkthrough/picoctf/pie_time/second_run.png "as we can see, re-running the executable gives us another address")

From that second screenshot, you might be able to identify something.

> What should I.... Wait, we already saw that `33d`, at the end of the address...
{: .prompt-info }

Exactly !

The way the system handles PIE, is by generating an address, and putting the functions at the apropriate offsets.

But, usually the last byte is empty, so you can identify a function by it's address, if you know the offset.

I should warn, however, that that this is clearly not a _good_ way to identify functions, as colisions are entirely possible.

> Ok, that's cool, but how can this help us exploit this executable ?
{: .prompt-info }

Based on that, we know that the system gives a **base address**, and set the functions as offset to it.

We already know the offsets (the ones we retreived from objdump, `0x133d` for main, and `0x12a7` for win), we just need to know the base address.

On more complex challenges, you'd have to leak some function's address, through format string exploit, or anything.

But here, the level is `easy`, remember ?

We... already have the base address.

The program gives us the address of the `main` function.

And we know that, because of PIE, the `main` address is just the base address + the main's offset.

And we know the offset.

So we can calculate the base address by substracting the main's offset from the main's address.

Next, we can add back the offset of the `win` function, and retreive the address of the `win` function !

Let's try this out !

![exploiting the binary](/assets/img/posts/walkthrough/picoctf/pie_time/manually_exploiting_the_binary.png "exploiting the binary")

As you can see, we won !

As we were running on local, the `flag.txt` file was not present.

But it worked !!! Yayy !

Now, how did I end up with that address ?

$$
We are given the following addresses:

\[
\text{Address of main: } 0x63c913eb933d
\]
\[
\text{Offset of main: } 0x133d
\]

To calculate the base address, we subtract the offset from the address of main:

\[
\text{Base Address} = 0x63c913eb933d - 0x133d = 0x63c913eb8000
\]

Next, we know the offset of the "win" function:

\[
\text{Offset of win: } 0x12a7
\]

To calculate the jump address, we add the base address and the win offset:

\[
\text{Jump Address} = 0x63c913eb8000 + 0x12a7 = 0x63c913eb92a7
\]

Thus, the win address is \(0x63c913eb92a7\).
$$

# Conclusion

PIE is a powerfull defense system, and defenetly something you need to be aware of when exploiting low level binaries.

But, as all defense systems, it's not perfect, and if you are able to retreive the address of a function (called a "leak"), win it over.

Now that you know how to exploit it, you just need to connect to picoCTF's instance of that challenge, and win that CTF !

Happy hacking <3 !
