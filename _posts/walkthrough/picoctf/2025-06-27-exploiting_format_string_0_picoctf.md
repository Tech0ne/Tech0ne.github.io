---
title: Exploiting "Format String 0" on picoCTF
author: tech0ne
date: 2025-06-27 16:00:00 +0100
categories: [walkthrough, picoctf, binary-exploitation]
comments: true
toc: true
pin: false
tags: [walkthrough, picoctf, linux, programming, c, binary-exploitation, pwntools, format-string]
math: true
mermaid: true
---

# Introduction

Again, I just went on picoCTF, to make a CTF, and though it was cool, and I should make a post about it.

Hope you'll enjoy this one too !

## Disclamer

> As the last one, this is a COMPLETE WALKTHROUGH giving a FULL AND WORKING solution. It's HIGHLY advised to do the CTF before looking at this !
{: .prompt-danger }

# The CTF

This CTF (available [here](https://play.picoctf.org/practice/challenge/433?category=6&page=1)) is all about exploiting a simple format string vulnerability.

It an `easy` binary exploitation challenge introduced on "picoCTF 2024".

As before, we have access to:
- The C source code itself.
- The binary, running on the remote machine.

## Initial lookup

Here's the content of the original C source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 32
#define FLAGSIZE 64

char flag[FLAGSIZE];

void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}

int on_menu(char *burger, char *menu[], int count) {
    for (int i = 0; i < count; i++) {
        if (strcmp(burger, menu[i]) == 0)
            return 1;
    }
    return 0;
}

void serve_patrick();

void serve_bob();


int main(int argc, char **argv){
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL) {
        printf("%s %s", "Please create 'flag.txt' in this directory with your",
                        "own debugging flag.\n");
        exit(0);
    }

    fgets(flag, FLAGSIZE, f);
    signal(SIGSEGV, sigsegv_handler);

    gid_t gid = getegid();
    setresgid(gid, gid, gid);

    serve_patrick();
  
    return 0;
}

void serve_patrick() {
    printf("%s %s\n%s\n%s %s\n%s",
            "Welcome to our newly-opened burger place Pico 'n Patty!",
            "Can you help the picky customers find their favorite burger?",
            "Here comes the first customer Patrick who wants a giant bite.",
            "Please choose from the following burgers:",
            "Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice1[BUFSIZE];
    scanf("%s", choice1);
    char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
    if (!on_menu(choice1, menu1, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        int count = printf(choice1);
        if (count > 2 * BUFSIZE) {
            serve_bob();
        } else {
            printf("%s\n%s\n",
                    "Patrick is still hungry!",
                    "Try to serve him something of larger size!");
            fflush(stdout);
        }
    }
}

void serve_bob() {
    printf("\n%s %s\n%s %s\n%s %s\n%s",
            "Good job! Patrick is happy!",
            "Now can you serve the second customer?",
            "Sponge Bob wants something outrageous that would break the shop",
            "(better be served quick before the shop owner kicks you out!)",
            "Please choose from the following burgers:",
            "Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice2[BUFSIZE];
    scanf("%s", choice2);
    char *menu2[3] = {"Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"};
    if (!on_menu(choice2, menu2, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        printf(choice2);
        fflush(stdout);
    }
}
```
{: file="vuln.c" }

As you can see, it's way bigger than the previous one !

Like before, we'll start by checking the file using `checksec`:

![checksec on vuln](/assets/img/posts/walkthrough/picoctf/format_string_0/checksec.png "checksec on vuln")

(Yeah, there was an update since last time)

Ok, so no PIE this time ^^

We can run objdump, like last time, but there is no need here.

## Source code auditing

The first thing we come accross is that

```c
char flag[FLAGSIZE];
```

(after the `include`s and `define`s)

This probably means that the flag is stored globally. That's good to know.

This is confirmed if we look at the `main` function:

```c
int main(int argc, char **argv){
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL) {
        printf("%s %s", "Please create 'flag.txt' in this directory with your",
                        "own debugging flag.\n");
        exit(0);
    }

    fgets(flag, FLAGSIZE, f);
```

Ok, that means the flag is available to all functions. Good

Next, we see the definition of a `sigsegv_handler` function.

From it's name, we can think it's used to handle any SIGSEGV signal. We'll see what signals are in a bit, for now let's see what it does:

```c
void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}
```

Well, it just prints out the flag !

And, we can confirm it's used to handle SIGSEGV signals by looking at the next line on main:

```c
    signal(SIGSEGV, sigsegv_handler);
```

What all that means, is that, if we are able to trigger a SIGSEGV, we retreive the flag. As easy as that !

_If you ever wrote any C code, you know that this shouldn't be that hard ;)_

What else is available ?

```c
void serve_patrick() {
    printf("%s %s\n%s\n%s %s\n%s",
            "Welcome to our newly-opened burger place Pico 'n Patty!",
            "Can you help the picky customers find their favorite burger?",
            "Here comes the first customer Patrick who wants a giant bite.",
            "Please choose from the following burgers:",
            "Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice1[BUFSIZE];
    scanf("%s", choice1);
    char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
    if (!on_menu(choice1, menu1, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        int count = printf(choice1);
        if (count > 2 * BUFSIZE) {
            serve_bob();
        } else {
            printf("%s\n%s\n",
                    "Patrick is still hungry!",
                    "Try to serve him something of larger size!");
            fflush(stdout);
        }
    }
}
```

Wow, lot of stuff happening here.

To sum up what that function does, it'll:

- display stuff to the screen. stuff we don't care about
- read the user input to a buffer
- check if that input is part of a specified "burger list"
- if it's not, return from the function
- else, display our choice using printf (!)
- if the number of characters displayed by the printf call is more than the size of our buffer (which is, in theory, not possible), then continue execution to the `serve_bob` function
- else, return from the function

Ok, from here (mainly due to the use of scanf), we can already complete the room, but that'd be without using any format string exploit. Not what we want !

Before seeing how to exploit the next function (`serve_bob`), let's see how we can access it !

## Exploitation analysis

### First bypass

> The issue is that we have a buffer of size `BUFSIZE` (32 chars), but the function will only let us go through if we input something of size more than `2 * BUFSIZE` !
{: .prompt-info }

Well, not exactly.

If you look closely, the function check the variable `count` for the size.

And the value of `count` is the output of `printf(choice1)`, not exactly the length of our input !

And we controle the content of `choice1` !

This means, if we can input, within `choice1`, something that'll be printed as more than **64** chars, we can get through !

Luckly, there is also another constraint, which is that we have limited options:

- "Breakf@st_Burger"
- "Gr%114d_Cheese"
- "Bac0n_D3luxe"

Hmm, the second one seems intresting, no ?

> Why the second one specificly ?
{: .prompt-info }

Well, for one specific subpart of it: `%114d`

If you never used printf in C, I higly advice you to take a look at [this reference](https://en.cppreference.com/w/c/io/fprintf), which details a lot how the formatters work in C's printf.

Now that you've done that (because I'm sure you did that, even if you used printf before... Didn't you ??? üëÄ), you should understand why `%114d` is intresting.

If you still don't, don't worry !

We'll make a test together:

Here is a sample C code:

```c
#include <stdio.h>

int main()
{
    char* choice1 = "%114d\n";
    printf(choice1);
}
```

And here is it's output:

![why is %114d intresting](/assets/img/posts/walkthrough/picoctf/format_string_0/explain_format_string_formater.png "why is %114d intresting")

Here, what's intresting is not exactly the shown number, but rather the fact that there are a lot of spaces before it.

This is because printf will display exactly 114 characters for that integer, padding with spaces.

> And, 114 being over 64, we should be good, right ?
{: .prompt-info }

Exactly !

So, if we input that...

![first bypass](/assets/img/posts/walkthrough/picoctf/format_string_0/first_bypass.png "first bypass")

Okay !

First bypass done, it's your turn now, Sponge Bob.

### Second bypass

If we look at the code for the `serve_bob` function, it's exactly the same as the `serve_patrick`, except it just prints the input if we are able to bypass, no third step.

Allright, what can we do here ?

Well, not a lot more than before.

I wanted to show how formatters could help bypass size checks, but now we can simply trigger the segfault and get our flag.

> segfault you say ?
{: .prompt-info }

Ow, yeah, forgot to talk about that.

## Segmentation Fault

Quoted from [here](https://stackoverflow.com/questions/2346806/what-is-a-segmentation-fault#2346849):
> Segmentation fault is a specific kind of error caused by accessing memory that ‚Äúdoes not belong to you.‚Äù It‚Äôs a helper mechanism that keeps you from corrupting the memory and introducing hard-to-debug memory bugs.

I'd just like to add something: SIGSEGV is a _signal_, which then triggers the _error_.

A signal is just a "message" the kernel send to a process to give it information. For example, when you Ctrl+C a running process, what really happens is that you ask the kernel to send a SIGINT (for SIGnal INTerrupt) to the running process.

There are a lot of different signals, but the one intresting us today is SIGSEGV (SIGnal SEGmentation Violation)

It is sent by the kernel to ask for the process termination, due to invalid memory access.

But, on our target, due to that line

```c
    signal(SIGSEGV, sigsegv_handler);
```

we say "hey, if I receive a SIGSEGV signal, don't do the usual (kill the process), but just call the `sigsegv_handler` function plz".

And, the `sigsegv_handler` function display our flag.

So, we just need to find a way to break memory !

One easy way you might be familiar with is a buffer overflow.

A buffer overflow is a case when you try to put too much data in a buffer.

Due to how computer works (you can have a more detailed explanation of how this work in the "Simple Buffer Overflow" post I made !)), buffer overflow MIGHT not crash the process.

But, in our case we want it to crash, so we are gonna go full barbarian, and just dump a bunch of random data in there:

![getting the flag](/assets/img/posts/walkthrough/picoctf/format_string_0/getting_the_flag.png "getting the flag")

(That's why I said "we can already complete the room", inputing a lot of data, even to the first scanf would have been enough to win the room, a simple `python -c 'print("a"*48)' | nc picoctf-host picoctf-port` is enough to get the flag :} )

Lastly, I'd like to talk about something else.

`scanf` reads until '\n'. And strcmp stops on '\0' (string termination character).

This means that if you write past that initial '\0', this could theoraticly be interpreted by printf.

Unfortunatlly, printf also stops at '\0'.

What that means is we are able to successfully pass the `on_menu` check, which, in that particular case is not usefull to us.

# Conclusion

Well that was a good room !

We barelly touched the surface of what format string exploits can do, and it was easier to exploit a buffer overflow, but that's a good start !

As stated before, this room can be exploited with one bash command. So, I won't make a Python Pwntools script for it. But feel free to make your own !

Happy hacking <3
